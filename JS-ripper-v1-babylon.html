<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>GLB Normalizer + Floor Align (downscale-only fit)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #ui{position:fixed;left:10px;top:10px;z-index:10;display:flex;gap:8px;flex-wrap:wrap;align-items:center;color:#fff;font:14px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .btn{background:#111;color:#fff;border:1px solid #333;border-radius:10px;padding:8px 12px;cursor:pointer}
    canvas{position:fixed;inset:0;width:100vw;height:100vh;display:block}
    #stat{opacity:.8}
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="ui">
    <button id="pick" class="btn">Load GLB</button>
    <input id="file" type="file" accept=".glb,.gltf" style="display:none" />
    <button id="align" class="btn">Align Floor</button>
    <button id="frame" class="btn">Frame</button>
    <button id="spin"  class="btn">Spin: Off</button>
    <span id="stat"></span>
  </div>
  <canvas id="cv"></canvas>

  <script>
  // ---------- Engine & sizing ----------
  const canvas = document.getElementById('cv');
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true });
  function fitPixelRatio(){ engine.setHardwareScalingLevel(1/(window.devicePixelRatio||1)); engine.resize(); }
  new ResizeObserver(fitPixelRatio).observe(canvas); window.addEventListener('resize', fitPixelRatio); fitPixelRatio();

  // ---------- Scene (RIGHT-HANDED like glTF/three) ----------
  const scene = new BABYLON.Scene(engine);
  scene.useRightHandedSystem = true;
  scene.clearColor = new BABYLON.Color4(0,0,0,1);

  // Disable glTF autoplay animations
  BABYLON.SceneLoader.OnPluginActivatedObservable.add(loader => {
    if (loader.name === "gltf" && BABYLON.GLTFLoaderAnimationStartMode) {
      loader.animationStartMode = BABYLON.GLTFLoaderAnimationStartMode.NONE;
    }
  });

  // Camera/light
  const cam = new BABYLON.ArcRotateCamera("cam", 0.8, 1.2, 6, BABYLON.Vector3.Zero(), scene);
  cam.attachControl(canvas, true); cam.lowerRadiusLimit = 0.2;
  new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

  // Root node (we can spin this; the model itself stays fixed)
  const root = new BABYLON.TransformNode("root", scene);
  let spinOn = false;

  // Wireframe material (green)
  const GREEN = new BABYLON.Color3(0.13,0.77,0.37);
  const WIRE  = new BABYLON.StandardMaterial("wire", scene);
  WIRE.disableLighting = true; WIRE.emissiveColor = GREEN; WIRE.wireframe = true; WIRE.backFaceCulling = false;

  // Helpers
  function worldAABB(meshes){
    let min = new BABYLON.Vector3(+Infinity,+Infinity,+Infinity);
    let max = new BABYLON.Vector3(-Infinity,-Infinity,-Infinity);
    for (const m of meshes) {
      m.computeWorldMatrix(true);
      const bb = m.getBoundingInfo().boundingBox;
      min = BABYLON.Vector3.Minimize(min, bb.minimumWorld);
      max = BABYLON.Vector3.Maximize(max, bb.maximumWorld);
    }
    return {min,max};
  }

  // Downscale-only center & fit
  function centerAndFit(node, target = 3.2, downscaleOnly = true){
    const meshes = node.getChildMeshes(true).filter(m => (m.getTotalVertices?.()||0) > 0);
    if (!meshes.length) return;

    const {min, max} = worldAABB(meshes);
    const size   = max.subtract(min);
    const center = min.add(size.scale(0.5));

    // bring center to origin
    node.position = node.position.subtract(center);

    // compute scale; only shrink if too big
    const maxDim = Math.max(size.x, size.y, size.z, 1e-6);
    let s = target / maxDim;
    if (downscaleOnly && s > 1) s = 1;
    node.scaling = new BABYLON.Vector3(s, s, s);

    // refine centering post-scale
    const {min:min2, max:max2} = worldAABB(node.getChildMeshes(true));
    const center2 = min2.add(max2.subtract(min2).scale(0.5));
    node.position = node.position.subtract(center2);

    // camera framing proportional to final size
    const finalMaxDim = Math.max(max2.x-min2.x, max2.y-min2.y, max2.z-min2.z) || 1;
    cam.target = BABYLON.Vector3.Zero();
    cam.radius = Math.max(2.5, finalMaxDim * 0.9);
  }

  // Optional spin
  scene.onBeforeRenderObservable.add(() => {
    if (spinOn) root.rotation.y += engine.getDeltaTime()/1000 * 0.2;
  });
  engine.runRenderLoop(() => scene.render());

  // ---------- Hard-normalize utilities ----------
  function stopAndStripAllAnimations() {
    try {
      scene.stopAllAnimations();
      for (const ag of [...scene.animationGroups]) { ag.stop(); ag.reset(); ag.dispose(); }
      for (const a of [...scene.animatables]) { try { a.stop(); } catch {} }
    } catch {}
    for (const sk of scene.skeletons) { try { sk.returnToRest?.(); } catch {} }
  }

  function zeroTRSAndStripTracks(node) {
    const stack = [node];
    while (stack.length) {
      const n = stack.pop();
      if (n.animations && n.animations.length) n.animations.length = 0;
      if (n._animationPropertiesOverride) n._animationPropertiesOverride = null;
      if (n.rotationQuaternion) { n.rotationQuaternion = null; n.rotation = BABYLON.Vector3.Zero(); }
      if (n.rotation)  n.rotation  = BABYLON.Vector3.Zero();
      if (n.position)  n.position  = BABYLON.Vector3.Zero();
      if (n.setPivotMatrix) n.setPivotMatrix(BABYLON.Matrix.Identity());
      const kids = (n.getChildren && n.getChildren()) || [];
      for (const k of kids) stack.push(k);
    }
  }

  // ---------- Floor align ----------
  function fitBottomPlaneAndAlign(node){
    const meshes = node.getChildMeshes(true).filter(m => (m.getTotalVertices?.()||0) > 0);
    if (!meshes.length) return false;

    // Collect world-space vertices
    const pts = [];
    let globalMinY = +Infinity, globalMaxY = -Infinity;
    for (const m of meshes) {
      const pos = m.getVerticesData(BABYLON.VertexBuffer.PositionKind);
      if (!pos) continue;
      const wm = m.getWorldMatrix(true);
      for (let i=0;i<pos.length;i+=3){
        const v = BABYLON.Vector3.TransformCoordinates(
          new BABYLON.Vector3(pos[i], pos[i+1], pos[i+2]), wm
        );
        pts.push(v);
        if (v.y < globalMinY) globalMinY = v.y;
        if (v.y > globalMaxY) globalMaxY = v.y;
      }
    }
    if (pts.length < 3) return false;

    // Take the lowest ~1.5% of points
    const band = Math.max( (globalMaxY - globalMinY) * 0.015, 1e-6 );
    const floorPts = pts.filter(p => p.y <= globalMinY + band);
    if (floorPts.length < 3) return false;

    // Fit y = a*x + b*z + c via least squares
    let Sxx=0,Szz=0,Sxz=0,Sx=0,Sz=0,Sxy=0,Szy=0,Sy=0,N=0;
    for (const p of floorPts){
      Sxx += p.x*p.x; Szz += p.z*p.z; Sxz += p.x*p.z;
      Sx  += p.x;     Sz  += p.z;     Sy  += p.y;
      Sxy += p.x*p.y; Szy += p.z*p.y; N++;
    }
    function solve3(A,B){
      const [a11,a12,a13,a21,a22,a23,a31,a32,a33] = A;
      const det = a11*(a22*a33-a23*a32) - a12*(a21*a33-a23*a31) + a13*(a21*a32-a22*a31);
      if (Math.abs(det) < 1e-12) return null;
      function minor(i,j){
        const M=[[a11,a12,a13],[a21,a22,a23],[a31,a32,a33]];
        const rows=[0,1,2].filter(r=>r!==i), cols=[0,1,2].filter(c=>c!==j);
        return M[rows[0]][cols[0]]*M[rows[1]][cols[1]] - M[rows[0]][cols[1]]*M[rows[1]][cols[0]];
      }
      const inv = [
        minor(0,0)/det, -minor(1,0)/det,  minor(2,0)/det,
        -minor(0,1)/det, minor(1,1)/det, -minor(2,1)/det,
        minor(0,2)/det, -minor(1,2)/det, minor(2,2)/det
      ];
      return [
        inv[0]*B[0] + inv[1]*B[1] + inv[2]*B[2],
        inv[3]*B[0] + inv[4]*B[1] + inv[5]*B[2],
        inv[6]*B[0] + inv[7]*B[1] + inv[8]*B[2],
      ];
    }
    const A = [Sxx,Sxz,Sx,  Sxz,Szz,Sz,  Sx,Sz,N];
    const B = [Sxy,Szy,Sy];
    const sol = solve3(A,B);
    if (!sol) return false;
    const [a,b/*=z coeff*/,c] = sol;

    // Plane y = a*x + b*z + c  => normal n = (-a, 1, -b)
    let n = new BABYLON.Vector3(-a, 1, -b);
    if (n.length() < 1e-6) return false;
    n.normalize();

    // Rotate so n -> +Y
    const target = BABYLON.Vector3.Up();
    let axis = BABYLON.Vector3.Cross(n, target);
    const dot  = BABYLON.Vector3.Dot(n, target);
    if (axis.lengthSquared() < 1e-12) {
      if (dot < 0) {
        const q = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.X, Math.PI);
        node.rotationQuaternion = (node.rotationQuaternion || BABYLON.Quaternion.Identity()).multiply(q);
      }
    } else {
      axis.normalize();
      const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
      const q = BABYLON.Quaternion.RotationAxis(axis, angle);
      node.rotationQuaternion = (node.rotationQuaternion || BABYLON.Quaternion.Identity()).multiply(q);
    }
    return true;
  }

  // ---------- Loader (stable) ----------
  let isLoading = false;

  function clearImported(){ for (const ch of [...root.getChildren()]) ch.dispose(); }

  async function loadGLB_File(file){
    if (isLoading) return; isLoading = true;
    try {
      clearImported();
      const group = new BABYLON.TransformNode("import", scene);
      group.parent = root;

      const beforeMeshes = new Set(scene.meshes);
      const beforeNodes  = new Set(scene.transformNodes);

      const url = URL.createObjectURL(file);
      await BABYLON.SceneLoader.AppendAsync("", url, scene, null, ".glb"); // blob-safe

      const addedMeshes = scene.meshes.filter(m => !beforeMeshes.has(m));
      const addedNodes  = scene.transformNodes.filter(n => !beforeNodes.has(n));

      // Stop & strip any animation
      stopAndStripAllAnimations();
      for (const n of addedNodes)  zeroTRSAndStripTracks(n);
      for (const m of addedMeshes) zeroTRSAndStripTracks(m);

      // Re-parent under our group
      for (const m of addedMeshes) { try { m.parent = null; } catch {} }
      for (const n of addedNodes)  { if (n !== group && n !== root) { try { n.parent = null; } catch {} } }
      for (const n of addedNodes)  { if (n !== group && n !== root) n.parent = group; }
      for (const m of addedMeshes) { m.parent = group; }

      // Force visible, bake transforms, detach skeletons
      for (const m of group.getChildMeshes(true)) {
        m.material = WIRE;
        m.alwaysSelectAsActiveMesh = true;
        try { m.bakeCurrentTransformIntoVertices?.(); } catch {}
        if (m.skeleton) { try { m.skeleton.returnToRest?.(); } catch {} m.skeleton = null; }
        m.position = BABYLON.Vector3.Zero();
        m.rotation = BABYLON.Vector3.Zero();
        m.scaling  = new BABYLON.Vector3(1,1,1);
      }

      // Rough fit, align floor, then downscale-only fit (so we never blow up size)
      centerAndFit(group, 3.2, true);
      const aligned = fitBottomPlaneAndAlign(group);
      centerAndFit(group, 3.2, true);

      // Freeze
      for (const m of group.getChildMeshes(true)) { try { m.freezeWorldMatrix(); } catch {} }

      const verts = group.getChildMeshes(true).reduce((s,m)=>s+(m.getTotalVertices?.()||0),0);
      document.getElementById('stat').textContent =
        `Meshes: ${addedMeshes.length} | Verts: ${verts} ${aligned ? "| Aligned" : ""}`;
      console.log("[Loaded+Normalized+Aligned] meshes:", addedMeshes.length, "verts:", verts, "aligned:", aligned);
    } catch (e) {
      console.error("Load failed", e);
      alert("GLB load failed. See console.");
    } finally {
      const inp = document.getElementById('file'); inp.value = "";
      isLoading = false;
    }
  }

  // ---------- UI ----------
  document.getElementById('pick').addEventListener('click', ()=>{
    document.getElementById('file').click();
  });

  document.getElementById('file').addEventListener('change', async (e)=>{
    const file = e.target.files?.[0]; if (!file) return;
    await loadGLB_File(file);
  });

  document.getElementById('align').addEventListener('click', ()=>{
    const group = root.getChildren().find(n => n.name === "import");
    if (group) { fitBottomPlaneAndAlign(group); centerAndFit(group, 3.2, true); }
  });

  document.getElementById('frame').addEventListener('click', ()=>{
    centerAndFit(root, 3.2, true);
  });

  document.getElementById('spin').addEventListener('click', (ev)=>{
    spinOn = !spinOn;
    ev.target.textContent = `Spin: ${spinOn ? 'On' : 'Off'}`;
  });

  // optional placeholder so you see something at boot
  const ph = BABYLON.MeshBuilder.CreateIcoSphere("ph",{radius:1.2,subdivisions:2},scene);
  ph.material = WIRE; ph.parent = root;
  </script>
</body>
</html>
